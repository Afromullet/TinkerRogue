MAJOR



Room Decoration (maybe)
Larger map
Add equipping and removing items
Effect stacking
Correctly calculate player attributes once equipment is done. 
Add a text box that displays game info (Attacking, missing, etc)


When a creature is one square away from the player, it does not approach for whatever reason. I think this is related to how queeing actions works
Need better filling of actions on the action queue





___Energy/Time System__



* Throwing action needs to take time

* Clear ActionQueue if the entity no longer exists


__Throwing__


* Miss chance - tile isn't always hit

___Shooting__

For Cone, rectangle, and line shape, let it rotate around the player only when shooting 

Load shooting VX from JSON data

__Movement__





* Add Pack Movement - Only approach if N mothers are within r distance to the player

* Hit and Run - Attack then flee

* Fix bug that causes a creature to teleport if it tries to move into a blocked spot

* Consider using a different distance metric. There's implications to using Manhattan distance that I don't understand yet - especially in how it relates to diagonals


__Monster Bevavior__


* Monster with melee and ranged weapons should choose which attack to use 

* Allow creature to choose its target. Currently the attacks use the PlayerData

__Randomness__

* Item Spawning - Determine where to spawn items and spawn with random properties

* Creature Spawning - Spawn during map gen and when out of 


__Levels__


Clear entities on previous level unless they are in the room with the stairs. Need to store them 

Add more variety to the levels, including placeable items and tile variety



- - - - - - 

....Note....

Currently I create two slices of images. One from assets/tiles/walls and another from assets/tiles/floors.  The GameMap chooses a random tile to draw.  Also loading images from assets/tiles/decorations to add a small amount of flair. 
Not very complicated, but it will do for now. 

- - - - - - 



___Weapon and Armor__


* Equipping weapons and armor

* Allow StatusEffects n weapons to apply on hit

___Consumables__

* Add consumables


_n

___Refactoring__



Map Drawing

___GUI___

* Show player stats

* There's an issue when an item is thrown/consuable used that still contains the selected state. I.E, throwing the same object multiple
times in a row or using the same consumable multiple times in a row


___Other__




* Effect Stacking


* 

* Check on calls to make where slice is initialized with a size greater than 0. See if it works as intended, where we're just adding to it. Using append.
Might need to index instead

* Clean up all functions and methods which use a large number of parameters

* Add information, such as attack hits, misses, and damage done to the UI

* Throwing and shooting passes around lots of state. Refactor it. Especially in the way we use PlayerData. Also anything related to the drawing

* Create Shorter names for types and functions with long names



* Make things that are private...private. 

* Make sure there are no memory leaks when removing entities and slicing slices to remove data

* The way playerData and the UI interact. There's a lot of state being passed around and manipualted. Anything in input nees to be looked at too

* Make it simpler to call all the functions that take a lot of paramters

* Remove a dead creature once it dies rather than next turn

Preallocate sizes of slices when possible

Need a better way to handle coordinate conversions





________________

Major need for refacting

Everything in the main

IN the future, maybe decouple anything that passes data to the VX Handler

Everything in the input package

Everything in the worldmap package

Everything GUI related

Action Queue needs to have fewer redundant methods

PlayerData

________________

Problem with energy system - this is what someone described on discord that may help me discover issues with my current implemenation

In an energy system you generally want to treat everyone the same, and not really have an action queue per se
What you want is a list of all actors instead
You get through all of them, replenish energy based on speed, and then run a decision process
If the actor is a player then you break the turn processing and wait for the UI
If it's a mob then it should decide what it wants to do, and either it does the thing if it has energy, or does nothing
Then it'll decide again on the next go around
Even if you're doing complex behaviours you should just keep the state on the mob somehow, and break it down into single actions during the turn processing